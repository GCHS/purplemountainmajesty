<script>
{//greet the user: https://www.youtube.com/watch?v=65Gf6rlBQ-w
	let hourHand = new Date().getHours();
	if(hourHand >= 6 && hourHand < 12){
		console.log("Good morning!");
	}else if(hourHand >= 12 && hourHand < 18){
		console.log("Good afternoon!");
	}else if(hourHand >= 18){
		console.log("Good evening!");
	}else if(hourHand < 6){
		console.log("Insomnia, huh?");
	}
}

document.querySelectorAll(".footnote-ref").forEach(fillFootnoteTag);
window.onclick = ()=>{document.querySelectorAll(".footnote").forEach(hideFootnote)};//nested footnotes are instantiated on demand, which is why they're requeried
//nested footnotes are done on demand because I make directed cyclic graphs out of them.
//you've been warned.
{
	let footnotes = document.querySelector(".footnotes");
	if(footnotes)
		footnotes.classList.add("collapsed");//they're redundant now; hide them
}

function hideFootnote(f){
	f.querySelectorAll(".popup").forEach(hidePopup)
}
function hidePopup(p){
	p.classList.remove(
		"visible", "show-above", "show-below", "show-left", "show-right", "shorter-horizontal-line", "skinny"
	);
}

function hideSiblingFootnotes(f){
	//walk up DOM to find the enclosing footnote or body and then hide all the footnotes in it that aren't this one (footnotes aren't supposed to spawn with visible child footnotes)
	let ancestor = f.parentNode;
	for(; !(ancestor.classList && ancestor.tagName === "BODY" || ancestor.classList.contains("footnote")); ancestor = ancestor.parentNode);
	ancestor.querySelectorAll(".footnote").forEach(footnote =>{
		if(footnote != f){
			hideFootnote(footnote);
		}
	});
}

function hideVisibleChildPopupsXorContainingPopup(e){//called when popup body is clicked
	//child popups should only be visible if this popup is visible
	//if they are, hide them
	if(!window.getSelection().toString()) {//don't toggle popups on text selection
		let visibleChildPopups = e.currentTarget.querySelectorAll(".visible");
		if(visibleChildPopups.length){
			visibleChildPopups.forEach(hidePopup);
		}else{
			hidePopup(e.currentTarget.parentNode);
		}
	}
	e.stopPropagation();
}
function footnoteToggler(e){//called when the footnote tag, `[n]`, is clicked
	if(!window.getSelection().toString()) {//don't toggle popups on text selection
		popup = e.currentTarget.querySelector(".popup");
		if(popup.classList.toggle("visible")){
			hideSiblingFootnotes(e.currentTarget);
			showPopup(popup);
		}else{
			hidePopup(popup);
		}
	}
	e.stopPropagation();
}

function showPopup(popup){
	popup.classList.add("show-above", "show-right");
	fitPopupHorizontally(popup);
	fitPopupVertically(popup);
}

function fitPopupHorizontally(popup){
	//the first child of a popup is its architects-line.
	//We use the bounding box of that element because its x-skew means that the coallated bounding box width for the whole popup is calculated in a weird way,
	//but the bounding box for the architects-line is, itself, correct, and it is the width of the whole popup.
	let boundingBox = popup.firstElementChild.getBoundingClientRect();
	let viewportWidth = window.visualViewport? window.visualViewport.width : (window.innerWidth || document.documentElement.clientWidth);
	//if it's off the right of the viewport, we've got work to do
	if(boundingBox.right > viewportWidth){
		if(boundingBox.left - boundingBox.width >= 0){//if it will fit in the viewport if it points to the left, point it to the left
			popup.classList.remove("show-right");
			popup.classList.add("show-left");
		}else{//if it doesn't fit, shorten the architects-line's horizontal
			popup.classList.add("shorter-horizontal-line");
			boundingBox = popup.firstElementChild.getBoundingClientRect();
			if(boundingBox.right > viewportWidth){
				if(boundingBox.left - boundingBox.width >= 0){//if it will fit in the viewport if it points to the left, point it to the left
					popup.classList.remove("show-right");
					popup.classList.add("show-left");
				}else{//if it /still/ doesn't fit, make it skinny
					popup.classList.add("skinny");
					boundingBox = popup.firstElementChild.getBoundingClientRect();
					if(boundingBox.right > viewportWidth && boundingBox.left - boundingBox.width >= 0){//if it will /only/ fit in the viewport if it points to the left, point it to the left
						popup.classList.remove("show-right");
						popup.classList.add("show-left");
					}//otherwise, leave it pointing right; even if it doesn't fit, being off on the right side of the page allows the user to scroll to see the rest of it
				}
			}
		}
	}
}

function fitPopupVertically(popup){
	let boundingBox = popup.getBoundingClientRect();
	if(boundingBox.top < 0){
		popup.classList.remove("show-above");
		popup.classList.add("show-below");
	}//if it still doesn't fit, the user can scroll down
}

function nestedFootnoteFiller(e){
	fillFootnoteTag(e.currentTarget);
	footnoteToggler(e);
}

function fillFootnoteTag(tag){
	tag.classList.add("footnote");
	let footernote = document.getElementById(tag.childNodes[0].getAttribute("href").substring(1));

	unanchorTag(tag);

	let popup = document.createElement("span");
	popup.classList.add("popup");
	popup.appendChild(document.createElement("architects-line"));
	let content = document.createElement("div");
	content.classList.add("popup-content");
	content.onclick = hideVisibleChildPopupsXorContainingPopup;
	footernote.childNodes.forEach(node => {
		content.appendChild(node.cloneNode(true));
	});
	content.querySelectorAll(".footnote").forEach(hideFootnote);
	popup.appendChild(content);
	popup.querySelectorAll(".footnote-ref").forEach(f => {
		unanchorTag(f);
		f.onclick = nestedFootnoteFiller;
	});
	popup.querySelectorAll(".footnote-backref").forEach(backref => {backref.remove();});
	tag.appendChild(popup);
	tag.onclick = footnoteToggler;
}

function unanchorTag(tag){ //replace a fragment link with its text to not send the user flying all over the page
	if(tag.firstChild.tagName === "A"){
		let footnotation = document.createElement("span");
		footnotation.textContent = tag.firstChild.text;
		footnotation.setAttribute("href", tag.firstChild.getAttribute("href"));
		footnotation.classList.add("footnotation");
		tag.replaceChild(footnotation, tag.firstChild);
	}
}
</script>