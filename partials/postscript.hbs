<script>
{//greet the user: https://www.youtube.com/watch?v=65Gf6rlBQ-w
	let hourHand = new Date().getHours();
	if(hourHand >= 6 && hourHand < 12){
		console.log("Good morning!");
	}else if(hourHand >= 12 && hourHand < 18){
		console.log("Good afternoon!");
	}else if(hourHand >= 18){
		console.log("Good evening!");
	}else if(hourHand < 6){
		console.log("Insomnia, huh?");
	}
}

document.querySelectorAll(".footnote-ref").forEach(fillFootnoteTag);
window.onclick = ()=>{document.querySelectorAll(".footnote").forEach(hideFootnote)};//nested footnotes are instantiated on demand, which is why they're requeried
//nested footnotes are done on demand because I make directed cyclic graphs out of them.
//you've been warned.
{
	let footnotes = document.querySelector(".footnotes");
	if(footnotes)
		footnotes.classList.add("collapsed");//they're redundant now; hide them
}

function hideFootnote(f){
	f.querySelectorAll(".popup").forEach(hidePopup)
}
function hidePopup(p){
	p.classList.remove(
		"visible", "show-above", "show-below", "show-left", "show-right", "shorter-horizontal-line", "skinny"
	);
}

function hideSiblingFootnotes(f){
	//walk up DOM to find the enclosing footnote or body and then hide all the footnotes in it that aren't this one (footnotes aren't supposed to spawn with visible child footnotes)
	let ancestor = f.parentNode;
	for(; !(ancestor.classList && ancestor.tagName === "BODY" || ancestor.classList.contains("footnote")); ancestor = ancestor.parentNode);
	ancestor.querySelectorAll(".footnote").forEach(footnote =>{
		if(footnote != f){
			hideFootnote(footnote);
		}
	});
}

function hideVisibleChildPopupsXorContainingPopup(e){//called when popup body is clicked
	//child popups should only be visible if this popup is visible
	//if they are, hide them
	if(!window.getSelection().toString()) {//don't toggle popups on text selection
		let visibleChildPopups = e.currentTarget.querySelectorAll(".visible");
		if(visibleChildPopups.length){
			visibleChildPopups.forEach(hidePopup);
		}else{
			hidePopup(e.currentTarget.parentNode);
		}
	}
	e.stopPropagation();
}
function footnoteToggler(e){//called when the footnote tag, `[n]`, is clicked
	if(!window.getSelection().toString()) {//don't toggle popups on text selection
		popup = e.currentTarget.querySelector(".popup");
		if(popup.classList.toggle("visible")){
			hideSiblingFootnotes(e.currentTarget);
			showPopup(popup);
		}else{
			hidePopup(popup);
		}
	}
	e.stopPropagation();
}

function showPopup(popup){
	popup.classList.add("show-above", "show-right");
	fitPopupHorizontally(popup);
	fitPopupVertically(popup);
}

function fitPopupHorizontally(popup){
	tryFitPopupHorizontally(popup, ["shorter-horizontal-line", "skinny"]);
}
function tryFitPopupHorizontally(popup, classesToTry){
	let viewportWidth = window.visualViewport? window.visualViewport.width : (window.innerWidth || document.documentElement.clientWidth);
	for(let i=0; !tryFitPopupWithHorizontalFlip(popup, viewportWidth) && i<classesToTry.length; i++){
		popup.classList.add(classesToTry[i]);
	}
}
function tryFitPopupWithHorizontalFlip(popup, maxRightCoord){
	//The first child of a popup is its architects-line.
	//We use the bounding box of that element because its x-skew means that the coallated bounding box width for the whole popup is calculated in a weird way,
	//but the bounding box for the architects-line is, itself, correct, and it is the width of the whole popup.
	let boundingBox = popup.firstElementChild.getBoundingClientRect();
	if(boundingBox.right <= maxRightCoord){//it fits!
		return true;
	}else{
		if(boundingBox.left - boundingBox.width >= 0){//if it will fit if it points to the left, point it to the left
			popup.classList.remove("show-right");
			popup.classList.add("show-left");
			return true;
		}else{
			return false;
		}
	}
}

function fitPopupVertically(popup){
	let boundingBox = popup.getBoundingClientRect();
	if(boundingBox.top < 0){
		popup.classList.remove("show-above");
		popup.classList.add("show-below");
	}//if it still doesn't fit, the user can scroll down
}

function nestedFootnoteFiller(e){
	fillFootnoteTag(e.currentTarget);
	footnoteToggler(e);
}

function fillFootnoteTag(tag){
	tag.classList.add("footnote");
	let footernote = document.getElementById(tag.childNodes[0].getAttribute("href").substring(1));

	unanchorTag(tag);

	let popup = document.createElement("span");
	popup.classList.add("popup");
	popup.appendChild(document.createElement("architects-line"));
	let content = document.createElement("div");
	content.classList.add("popup-content");
	content.onclick = hideVisibleChildPopupsXorContainingPopup;
	footernote.childNodes.forEach(node => {
		content.appendChild(node.cloneNode(true));
	});
	content.querySelectorAll(".footnote").forEach(hideFootnote);
	popup.appendChild(content);
	popup.querySelectorAll(".footnote-ref").forEach(f => {
		unanchorTag(f);
		f.onclick = nestedFootnoteFiller;
	});
	popup.querySelectorAll(".footnote-backref").forEach(backref => {backref.remove();});
	tag.appendChild(popup);
	tag.onclick = footnoteToggler;
}

function unanchorTag(tag){ //replace a fragment link with its text to not send the user flying all over the page
	if(tag.firstChild.tagName === "A"){
		let footnotation = document.createElement("span");
		footnotation.textContent = tag.firstChild.text;
		footnotation.setAttribute("href", tag.firstChild.getAttribute("href"));
		footnotation.classList.add("footnotation");
		tag.replaceChild(footnotation, tag.firstChild);
	}
}
</script>